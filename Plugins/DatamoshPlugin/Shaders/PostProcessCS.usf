// Custom SceneViewExtension Template for Unreal Engine
// Copyright 2023 - 2025 Ossi Luoto
// 
// Custom CS PostProcessing Shader

#include "/Engine/Public/Platform.ush"
#include "/Engine/Private/Common.ush"
#include "/Engine/Private/ScreenPass.ush"

// Shader parameters

// SceneColor texture
Texture2D OriginalSceneColor;
Texture2D VelocityFluid;
Texture2D PreviousFrame;
Texture2D Velocity;


// SceneColor Viewport parameters
SCREEN_PASS_TEXTURE_VIEWPORT(SceneColorViewport)

SCREEN_PASS_TEXTURE_VIEWPORT(SceneVelocityViewport)

// Outputs

RWTexture2D<float4> Output;

RWTexture2D<float4> VelocityFluidOutput;

float4 GaussianSample(
	const Texture2D Texture,
	const float2 screen_size,
	const float2 UvCenter
)
{
	const float Guassian_Kernel[9] = {
		1.0 / 16, 2.0 / 16, 1.0 / 16,
		2.0 / 16, 4.0 / 16, 2.0 / 16,
		1.0 / 16, 2.0 / 16, 1.0 / 16
	};

	const uint GaussianKernelSize = 9;

	const float2 offset = float2(1., 1.) / screen_size;

	const float2 offsets[9] = {
		float2(-offset.x, offset.y), // top-left
		float2(0.0f, offset.y), // top-center
		float2(offset.x, offset.y), // top-right
		float2(-offset.x, 0.0f), // center-left
		float2(0.0f, 0.0f), // center-center
		float2(offset.x, 0.0f), // center-right
		float2(-offset.x, -offset.y), // bottom-left
		float2(0.0f, -offset.y), // bottom-center
		float2(offset.x, -offset.y) // bottom-right
	};


	float4 GuassianSample = float4(0., 0., 0., 0.);

	for (uint i = 0; i < GaussianKernelSize; i++)
	{
		float2 Uv = UvCenter + offsets[i] * Guassian_Kernel[i];
		GuassianSample += Texture.SampleLevel(GlobalPointClampedSampler, Uv, 0);
	}

	// return GuassianSample;
	return Texture.SampleLevel(GlobalPointClampedSampler, UvCenter, 0);
}

// Compute Shader code
[numthreads(THREADS_X, THREADS_Y, THREADS_Z)]
void MainCS(uint2 DispatchThreadId : SV_DispatchThreadID)
{
	// Check that we are in scope
	if (any(DispatchThreadId >= SceneColorViewport_ViewportMax))
	{
		return;
	}

	// Calculate SampleUV with viewport parameters
	const float2 SceneColorUV =
		(float2(SceneColorViewport_ViewportMin) + (DispatchThreadId + 0.5)) * SceneColorViewport_ExtentInverse;

	const float2 VelocityUV =
		SceneColorUV * (SceneVelocityViewport_UVViewportMax - SceneVelocityViewport_UVViewportMin) +
		SceneVelocityViewport_ViewportMin;

	float4 FragmentVelocity = GaussianSample(
		Velocity,
		float2(SceneVelocityViewport_ViewportMax - SceneVelocityViewport_ViewportMin),
		VelocityUV
	);

	if (length2(FragmentVelocity) > 0.)
	{
		FragmentVelocity.xy = DecodeVelocityFromTexture(FragmentVelocity).xy;
	}

	// velocity = 4.008 * velocity - 0.5 * 4.008;

	float4 OriginalVelocity = GaussianSample(
		VelocityFluid,
		float2(SceneColorViewport_ViewportMax - SceneColorViewport_ViewportMin),
		VelocityUV - FragmentVelocity.xy * 0.1f
	);

	OriginalVelocity = 0.999 * OriginalVelocity;
	OriginalVelocity += FragmentVelocity;

	const float2 Offset = OriginalVelocity * 0.1f;
	const float4 OriginalColor = OriginalSceneColor.SampleLevel(GlobalPointClampedSampler, SceneColorUV - Offset, 0);


	Output[SceneColorViewport_ViewportMin + DispatchThreadId] = OriginalColor;
	VelocityFluidOutput[SceneColorViewport_ViewportMin + DispatchThreadId] = OriginalVelocity;
	// Output[SceneColorViewport_ViewportMin + DispatchThreadId] = OriginalVelocity;
}
